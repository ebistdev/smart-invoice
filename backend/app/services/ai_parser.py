"""
AI Invoice Parser - Extract line items from natural language.

SAFETY: This service ONLY extracts items and quantities.
Prices ALWAYS come from the user's rate card - never AI-generated.
"""

import json
import re
from decimal import Decimal
from typing import Optional
from pydantic import BaseModel
import httpx

from app.config import get_settings

settings = get_settings()


class ParsedLineItem(BaseModel):
    """AI-extracted line item (no price - that comes from rate card)."""
    item_key: str  # e.g., "labor.troubleshooting" or "materials.30-amp breaker"
    quantity: Decimal
    notes: Optional[str] = None
    confidence: float = 1.0  # How confident the AI is in this match


class ParsedInvoice(BaseModel):
    """AI-extracted invoice data."""
    line_items: list[ParsedLineItem]
    client_name: Optional[str] = None
    work_date: Optional[str] = None
    notes: Optional[str] = None
    unmatched_items: list[str] = []  # Items AI couldn't match to rate card


def build_rate_card_context(rate_items: list) -> str:
    """Build rate card JSON for the AI prompt."""
    rate_card = {"labor": {}, "materials": {}, "other": {}}
    
    for item in rate_items:
        category = item.category or "other"
        if category not in rate_card:
            rate_card[category] = {}
        
        key = f"{category}.{item.name.lower()}"
        rate_card[category][item.name.lower()] = {
            "key": key,
            "name": item.name,
            "unit": item.unit,
            "aliases": item.aliases or []
        }
    
    return json.dumps(rate_card, indent=2)


def build_extraction_prompt(user_input: str, rate_card_json: str) -> str:
    """Build the AI prompt for extracting invoice items."""
    return f"""You are an invoice line-item extractor. Extract billable items from the work description.

RATE CARD (available items):
{rate_card_json}

WORK DESCRIPTION:
"{user_input}"

EXTRACTION RULES:
1. ONLY use item_key values that exist in the rate card
2. Parse quantities carefully:
   - "3 hours" → 3.0
   - "half hour" → 0.5
   - "45 minutes" → 0.75
   - "a breaker" or "1 breaker" → 1
3. If an item doesn't match the rate card, add it to "unmatched_items"
4. Extract client name if mentioned
5. Extract work date if mentioned

OUTPUT FORMAT (JSON only, no markdown):
{{
  "line_items": [
    {{"item_key": "category.item_name", "quantity": 1.0, "notes": "optional detail", "confidence": 0.95}}
  ],
  "client_name": "Client Name or null",
  "work_date": "YYYY-MM-DD or null",
  "notes": "any additional notes",
  "unmatched_items": ["items that couldn't be matched"]
}}

IMPORTANT: Output ONLY valid JSON, no explanation or markdown."""


async def parse_work_description(
    user_input: str,
    rate_items: list,
    provider: str = None,
    model: str = None
) -> ParsedInvoice:
    """
    Parse natural language work description into invoice line items.
    
    SAFETY: This function extracts items and quantities only.
    Prices are NEVER generated by AI - they come from the rate card.
    """
    provider = provider or settings.llm_provider
    model = model or settings.llm_model
    
    rate_card_json = build_rate_card_context(rate_items)
    prompt = build_extraction_prompt(user_input, rate_card_json)
    
    if provider == "anthropic":
        response_text = await _call_anthropic(prompt, model)
    elif provider == "openai":
        response_text = await _call_openai(prompt, model)
    else:
        raise ValueError(f"Unknown LLM provider: {provider}")
    
    # Parse the JSON response
    try:
        # Clean up potential markdown wrapping
        clean_response = response_text.strip()
        if clean_response.startswith("```"):
            clean_response = re.sub(r'^```(?:json)?\n?', '', clean_response)
            clean_response = re.sub(r'\n?```$', '', clean_response)
        
        data = json.loads(clean_response)
        
        # Convert to Pydantic model
        line_items = []
        for item in data.get("line_items", []):
            line_items.append(ParsedLineItem(
                item_key=item["item_key"],
                quantity=Decimal(str(item["quantity"])),
                notes=item.get("notes"),
                confidence=item.get("confidence", 1.0)
            ))
        
        return ParsedInvoice(
            line_items=line_items,
            client_name=data.get("client_name"),
            work_date=data.get("work_date"),
            notes=data.get("notes"),
            unmatched_items=data.get("unmatched_items", [])
        )
        
    except (json.JSONDecodeError, KeyError) as e:
        # Return empty result on parse failure
        return ParsedInvoice(
            line_items=[],
            unmatched_items=[f"Failed to parse: {str(e)}"]
        )


async def _call_anthropic(prompt: str, model: str) -> str:
    """Call Anthropic API."""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.anthropic.com/v1/messages",
            headers={
                "x-api-key": settings.anthropic_api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            },
            json={
                "model": model,
                "max_tokens": 1024,
                "messages": [{"role": "user", "content": prompt}]
            },
            timeout=30.0
        )
        response.raise_for_status()
        data = response.json()
        return data["content"][0]["text"]


async def _call_openai(prompt: str, model: str) -> str:
    """Call OpenAI API."""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {settings.openai_api_key}",
                "Content-Type": "application/json"
            },
            json={
                "model": model,
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 1024,
                "temperature": 0.1
            },
            timeout=30.0
        )
        response.raise_for_status()
        data = response.json()
        return data["choices"][0]["message"]["content"]
